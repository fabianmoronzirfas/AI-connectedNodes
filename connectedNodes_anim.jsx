// connectedNodes_anim.jsx// see the video to this script over at vimeo// http://vimeo.com/28665864 (lowres)// the nodes get connected by their distance to each other// if a node connects the range it can connect with other nodes increases// color and opacity also change according to the connections//// see also the processing code --> http://fabiantheblind.tumblr.com/post/9878896421/connected-nodes-processing//// Copyright (c)  2012 Fabian "fabiantheblind" Morón Zirfas// Permission is hereby granted, free of charge, to any person obtaining a copy of this// software and associated documentation files (the "Software"), to deal in the Software // without restriction, including without limitation the rights to use, copy, modify, // merge, publish, distribute, sublicense, and/or sell copies of the Software, and to // permit persons to whom the Software is furnished to do so, subject to the following // conditions:// The above copyright notice and this permission notice shall be included in all copies // or substantial portions of the Software.// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF // CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE // OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.// see also http://www.opensource.org/licenses/mit-license.phpmain();function main(){var DEBUG = true;//the more nodes the more it will bee connected// number of nodes. Between 1500 and 2500 is nice// or you sice up the documentsizevar num = 50; var distance = 5; // the startin distance to reach for others// this is the factor that increments the "reach / distance"// a node can connect with othersvar incrFac = 2; // keep this very lowvar frames = 10;var nodes = new Array(); // an array to keep the nodes in// some defaultsvar w = 100;var h = 50;  // this initalizes the nodes        // loop thru num o nodes    for(var i = 0; i < num; i++){      // make a random points       var x = Math.random()*w;      var y = Math.random()*h;      var pos = [x,y];// position into PVector       nodes.push(pos); // add the new node to the list    }// close first loop  for(var fr = 0; fr < frames; fr++){var docPreset = new DocumentPreset;docPreset.width = w;docPreset.height = h;docPreset.units = RulerUnits.Pixels;var doc = documents.addDocument(DocumentColorSpace.RGB, docPreset);var width = doc.width;var height = doc.height;doc.defaultStrokeCap = StrokeCap.ROUNDENDCAP;// colorsvar fillColor = new RGBColor;fillColor.red = 190;fillColor.green = 190;fillColor.blue = 190;var strkColor = new RGBColor;strkColor.red = 128;strkColor.green = 128;strkColor.blue = 128;var n;// keep it clear         for(var j = 0; j < nodes.length; j++){    var f = 190; // the inital colorvalue    var fillColor = new RGBColor;        fillColor.red = f;        fillColor.green = f;        fillColor.blue = f;                n = nodes[j];        var diam = 3;// start diameter        var o = 23; // start opacity    // call the functions of node       var cons = 0; // number of connections  for(var k = 0; k < nodes.length; k ++){      var  v1 = n; // position of the refrence positoin      var  v2 = nodes[k]; // every other node            // these are the points of the node and the      // other nodes in the loop      // only for testing      var x =  v1[0];      var y =  v1[1];      var x0 = v2[0];      var y0 = v2[1];            var d = calcDistance(n,nodes[k]);// clac distance      // now if the node already has some connections      // make the diastance he can check higher                  if((d < distance +cons*incrFac ) &&(d > 1)){                    // create the lines       var myLine = doc.pathItems.add();        myLine.stroked = true;        myLine.setEntirePath( Array(nodes[k], n));        myLine.strokeColor = strkColor;        myLine.filled = false;        myLine.strokeWidth = 0.5;        myLine.opacity = o;               var lnsTags = myLine.tags.add();     lnsTags.name = "line";                      // now there is a connection              // so increment all the values                cons++; // increment num                diam+=0.25;                o++;                f++; // or decrement. as you like (this makes it lighter)                // constrain the opacity                if(o >= 90){                    o = 90;                     }// close opacity constrain      }// close if  }  //close loop K    // create the node / ellipse    var ell = doc.pathItems.ellipse(n[1] + diam/2,n[0] -diam/2, diam, diam, true,true );    if(f <=0){f=0;}// constrain f (fillcolor)    if(f >=255){f=255;}// constrain f (fillcolor)        fillColor.red = f;    fillColor.green = f;    fillColor.blue = f;    ell.fillColor = fillColor;     ell.strokeColor = strkColor;     ell.strokeWidth = 0.5;     ell.opacity = o;     var ellsTag = ell.tags.add();     ellsTag.name = "ellipse";      } // close loop J        for(var l = 0; l < doc.pathItems.length; l++){    var p = doc.pathItems[l];    if(p.tags[0].name.match("ellipse")){        p.zOrder(ZOrderMethod.BRINGTOFRONT);        }    } // end L loop        // update the nodes position    updateNodes(nodes,w,h);    $.writeln(fr);   }// close frame loop }// close main// found on the web// http://www.mathopenref.com/coorddist.htmlfunction calcDistance  ( p, q){   var dx   = p[0] - q[0];         //horizontal difference   var dy   = p[1] - q[1];         //vertical difference   var dist = Math.sqrt( dx*dx + dy*dy ); //distance using Pythagoras theorem  return dist;}// this shifts the nodes aroundfunction updateNodes(nodes,w,h){        for(var m = 0; m < nodes.length; m++){        var n = nodes[m];                n[0] = n[0] + Math.random()*2 - 1;        n[1] = n[1] + Math.random()*2 - 1;                checkEdges(n,w,h);        }    }function checkEdges(n,w,h){         if (n[0] > w) {      n[0] = 0;    } else if (n[0] < 0) {      n[0] = w;    } // X        if (n[1] > h) {      n[1] = 0;    } else if (n[1] < 0) {      n[1] = h;    }// Y        }